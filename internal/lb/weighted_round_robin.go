// internal/lb/weighted_round_robin.go
package lb

import (
	"math/rand"
	"sync"
	"time"

	"load-balancer/internal/server"
)

// WeightedRoundRobin implements weighted RR to pick a server based on CurrentWeight.
type WeightedRoundRobin struct {
	mu            sync.Mutex      // mutex for thread safety
	ServerManager *server.Manager // reference to the server manager
	randSource    *rand.Rand      // random number generator
}

// NewWeightedRoundRobin creates a WeightedRoundRobin instance.
func NewWeightedRoundRobin(mgr *server.Manager) *WeightedRoundRobin {
	return &WeightedRoundRobin{ // returns a new instance of the WeightedRoundRobin struct
		ServerManager: mgr,
		randSource:    rand.New(rand.NewSource(time.Now().UnixNano())),
		//The line randSource: rand.New(rand.NewSource(time.Now().UnixNano())) is used to initialize a random number
		//generator with a unique seed value. This ensures that the random numbers generated by the load balancer
		//are not predictable or repetitive.
	}
}

// PickServer picks a server based on their CurrentWeight, skipping those in Open CB state.
func (w *WeightedRoundRobin) PickServer() *server.Server {
	w.mu.Lock()
	defer w.mu.Unlock()

	servers := w.ServerManager.GetAllServers()
	if len(servers) == 0 {
		return nil // no servers are active
	}

	// Calculate total weight among servers that are not in Open state
	totalWeight := 0.0
	for _, srv := range servers {
		if srv.CircuitBreakerState != server.CBStateOpen {
			totalWeight += srv.CurrentWeight
		}
	}

	if totalWeight <= 0 {
		return nil // no server has a positive weight // all servers unhealthy
	}

	randVal := w.randSource.Float64() * totalWeight // random value between [0.0,1.0] * totalWeight
	runningSum := 0.0
	for _, srv := range servers {
		if srv.CircuitBreakerState == server.CBStateOpen {
			continue
		}
		runningSum += srv.CurrentWeight
		if randVal < runningSum {
			return srv
		}
	}

	// Fallback if something unexpected happens
	return nil
}
